using System.Text;

namespace UnionGen;

internal readonly struct UnionGenHelper(UnionToGenerate union)
{
    private const string TypeLookupFunc = "GetActualTypeName";
    private const string IndexParameterName = "index";
    private const string IndexFieldName = $"_{IndexParameterName}";
    private const string ValueParameterName = "value";
    private const string ValueFieldNamePrefix = $"_{ValueParameterName}";

    public string GeneratePartialStruct()
    {
        var (typeFields, typeProperties) = GenerateFieldsAndProperties();

        var code = $$"""
                     {{UnionSourceGen.AutoGeneratedComment}}
                     namespace {{union.Namespace}}
                     {
                         public readonly partial struct {{union.Name}}
                         {
                     {{typeFields}}
                     {{GenerateConstructors()}}
                     {{typeProperties}}
                     {{GenerateAccessors()}}
                     {{GenerateImplicitOperators()}}
                     {{GenerateMatch()}}
                     {{GenerateSwitch()}}
                     {{GenerateGetActualTypeName()}}
                         }
                     }
                     """;

        return code;
    }

    private string GenerateSwitch()
    {
        var parameters = new StringBuilder();
        var cases = new IndentedStringBuilder(4);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var rawType = union.TypeParameters[i];
            var type = EnsureTitleCase(rawType);
            var actionName = $"for{type}";
            parameters.Append($"Action<{rawType}> {actionName}");
            if (i < union.TypeParameters.Count - 1)
            {
                parameters.Append(", ");
            }
            cases.AppendLine($"case {i}: {actionName}({ValueFieldNamePrefix}{i}); break;");
        }
        cases.AppendLine($"default: throw new InvalidOperationException($\"Unknown type index {{{IndexFieldName}}}\");");
        
        var switchMethod = new IndentedStringBuilder(2, "public void Switch(");
        switchMethod.Append(parameters.ToString());
        switchMethod.Append(")");
        switchMethod.AppendLine(string.Empty);
        switchMethod.AppendLine("{");
        switchMethod.AppendLine($"switch ({IndexFieldName})", 1);
        switchMethod.AppendLine("{", 1);
        switchMethod.Append(cases.ToString());
        switchMethod.AppendLine("}", 1);
        switchMethod.AppendLine("}");
        
        return switchMethod.ToString();
    }
    
    private string GenerateMatch()
    {
        var parameters = new StringBuilder();
        var cases = new IndentedStringBuilder(4);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var rawType = union.TypeParameters[i];
            var type = EnsureTitleCase(rawType);
            var funcName = $"with{type}";
            parameters.Append($"Func<{rawType}, TResult> {funcName}");
            if (i < union.TypeParameters.Count - 1)
            {
                parameters.Append(", ");
            }
            cases.AppendLine($"{i} => {funcName}({ValueFieldNamePrefix}{i}),");
        }
        cases.AppendLine($"_ => throw new InvalidOperationException($\"Unknown type index {{{IndexFieldName}}}\")");

        var matchMethod = new IndentedStringBuilder(2, $"public TResult Match<TResult>({parameters})");
        matchMethod.Append(" => ");
        matchMethod.AppendLine(string.Empty);
        matchMethod.AppendLine($"{IndexFieldName} switch", 1);
        matchMethod.AppendLine("{", 1);
        matchMethod.Append(cases);
        matchMethod.AppendLine("};", 1);
        //matchMethod.AppendLine("}");

        return matchMethod.ToString();
    }
    
    private string GenerateImplicitOperators()
    {
        var operators = new IndentedStringBuilder(2);

        foreach (var type in union.TypeParameters)
        {
            operators.AppendLine($"public static implicit operator {union.Name}({type} {ValueParameterName}) => new {union.Name}({ValueParameterName});");
        }

        return operators.ToString();
    }

    private string GenerateConstructors()
    {
        var constructors = new IndentedStringBuilder(2, $"{GeneratePrivateConstructor()}{IndentedStringBuilder.NewLine}");
        
        for (var index = 0; index < union.TypeParameters.Count; index++)
        {
            var type = union.TypeParameters[index];
            var constructor = new IndentedStringBuilder(0, $"public {union.Name}({type} {ValueParameterName})");
            constructor.Append($": this({index}, {ValueParameterName}{index}: {ValueParameterName}) {{}}");
            constructors.AppendLine(constructor.ToString());
        }
        
        constructors.AppendLine($"public {union.Name}(): this(-1) {{}}");

        return constructors.ToString();
    }
    
    private string GeneratePrivateConstructor()
    {
        var parameters = new StringBuilder($"byte {IndexParameterName}, ");
        var assignments = new IndentedStringBuilder(3, $"{IndexFieldName} = {IndexParameterName};{IndentedStringBuilder.NewLine}");
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var type = union.TypeParameters[i];
            parameters.Append($"{type} {ValueParameterName}{i} = default");
            if (i < union.TypeParameters.Count - 1)
            {
                parameters.Append(", ");
            }
            assignments.AppendLine($"{ValueFieldNamePrefix}{i} = {ValueParameterName}{i};");
        }
        var constructor = new IndentedStringBuilder(0, $"private {union.Name}({parameters}){IndentedStringBuilder.NewLine}");
        constructor.AppendLine("{", 2);
        constructor.Append(assignments.ToString());
        constructor.AppendLine("}", 2);
        
        return constructor.ToString();
    }

    private string GenerateGetActualTypeName()
    {
        var func = new IndentedStringBuilder(2, $"public string {TypeLookupFunc}(){IndentedStringBuilder.NewLine}");
        func.AppendLine("{");
        func.AppendLine($"return {IndexFieldName} switch ", 1);
        func.AppendLine("{", 1);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var type = union.TypeParameters[i];
            func.AppendLine($"{i} => \"{type}\",", 2);
        }
        func.AppendLine($"_ => throw new InvalidOperationException($\"Unknown type index {{{IndexFieldName}}}\")", 2);
        func.AppendLine("};", 1);
        func.AppendLine("}");

        return func.ToString();
    }

    private string GenerateAccessors()
    {
        var accessors = new IndentedStringBuilder(2);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var rawType = union.TypeParameters[i];
            var type = EnsureTitleCase(rawType);
            accessors.AppendLine($"public {rawType} As{type}() =>");
            accessors.AppendLine($"Is{type}", 1);
            accessors.AppendLine($"? {ValueFieldNamePrefix}{i}", 2);
            accessors.AppendLine($": throw new InvalidOperationException($\"Is not of type {rawType} but type {{{TypeLookupFunc}()}}\");", 2);

            if (i < union.TypeParameters.Count - 1)
            {
                accessors.AppendLine(string.Empty);
            }
        }
        
        return accessors.ToString();
    }

    private (string TypeFields, string TypeProperties) GenerateFieldsAndProperties()
    {
        var typeFields = new IndentedStringBuilder(2,
                                                   $"private readonly byte {IndexFieldName};{IndentedStringBuilder.NewLine}");
        var typeProperties = new IndentedStringBuilder(2);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var type = union.TypeParameters[i];
            
            typeFields.AppendLine($"private readonly {type} {ValueFieldNamePrefix}{i};");
            typeProperties.AppendLine($"public bool Is{EnsureTitleCase(type)} => {IndexFieldName} == {i};");
        }

        return (typeFields.ToString(), typeProperties.ToString());
    }
    
    private static string EnsureTitleCase(string type)
    {
        Span<char> t = type.ToCharArray();
        t[0] = char.ToUpper(t[0]);
        return t.ToString();
    }
}
