using System.Text;

namespace UnionGen;

internal readonly struct UnionGenHelper(UnionToGenerate union)
{
    private const string TypeLookupFunc = "GetActualTypeName";
    private const string IndexParameterName = "index";
    private const string IndexFieldName = $"_{IndexParameterName}";
    private const string ValueParameterName = "value";
    private const string ValueFieldNamePrefix = $"_{ValueParameterName}";

    public string GeneratePartialStruct()
    {
        var (typeFields, typeProperties) = GenerateFieldsAndProperties();

        var code = $$"""
                     {{UnionSourceGen.AutoGeneratedComment}}
                     namespace {{union.Namespace}}
                     {
                         public readonly partial struct {{union.Name}}
                         {
                     {{typeFields}}
                     {{GenerateConstructors()}}
                     {{typeProperties}}
                     
                     {{GenerateAccessors()}}
                     
                     {{GenerateGetActualTypeName()}}
                         }
                     }
                     """;

        return code;
    }

    private string GenerateConstructors()
    {
        var constructors = new IndentedStringBuilder(2, $"{GeneratePrivateConstructor()}{IndentedStringBuilder.NewLine}");
        
        for (var index = 0; index < union.TypeParameters.Count; index++)
        {
            var type = union.TypeParameters[index];
            var constructor = new IndentedStringBuilder(0, $"public {union.Name}({type} {ValueParameterName})");
            constructor.Append($": this({index}, {ValueParameterName}{index}: {ValueParameterName}) {{}}");
            constructors.AppendLine(constructor.ToString());
        }
        
        constructors.AppendLine($"public {union.Name}(): this(-1) {{}}");

        return constructors.ToString();
    }
    
    private string GeneratePrivateConstructor()
    {
        var parameters = new StringBuilder($"int {IndexParameterName}, ");
        var assignments = new IndentedStringBuilder(3, $"{IndexFieldName} = {IndexParameterName};{IndentedStringBuilder.NewLine}");
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var type = union.TypeParameters[i];
            parameters.Append($"{type} {ValueParameterName}{i} = default");
            if (i < union.TypeParameters.Count - 1)
            {
                parameters.Append(", ");
            }
            assignments.AppendLine($"{ValueFieldNamePrefix}{i} = {ValueParameterName}{i};");
        }
        var constructor = new IndentedStringBuilder(0, $"private {union.Name}({parameters}){IndentedStringBuilder.NewLine}");
        constructor.AppendLine("{", 2);
        constructor.Append(assignments.ToString());
        constructor.AppendLine("}", 2);
        
        return constructor.ToString();
    }

    private string GenerateGetActualTypeName()
    {
        var func = new IndentedStringBuilder(2, $"public string {TypeLookupFunc}(){IndentedStringBuilder.NewLine}");
        func.AppendLine("{");
        func.AppendLine($"return {IndexFieldName} switch ", 1);
        func.AppendLine("{", 1);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var type = union.TypeParameters[i];
            func.AppendLine($"{i} => \"{type}\",", 2);
        }
        func.AppendLine($"_ => throw new InvalidOperationException($\"Unknown type index {{{IndexFieldName}}}\")", 2);
        func.AppendLine("};", 1);
        func.AppendLine("}");

        return func.ToString();
    }

    private string GenerateAccessors()
    {
        var accessors = new IndentedStringBuilder(2);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var rawType = union.TypeParameters[i];
            var type = EnsureTitleCase(rawType);
            accessors.AppendLine($"public {rawType} As{type}() =>");
            accessors.AppendLine($"Is{type}", 1);
            accessors.AppendLine($"? {ValueFieldNamePrefix}{i}", 2);
            accessors.AppendLine($": throw new InvalidOperationException($\"Is not of type {rawType} but type {{{TypeLookupFunc}()}}\");", 2);

            if (i < union.TypeParameters.Count - 1)
            {
                accessors.AppendLine(string.Empty);
            }
        }
        
        return accessors.ToString();
    }

    private (string TypeFields, string TypeProperties) GenerateFieldsAndProperties()
    {
        var typeFields = new IndentedStringBuilder(2,
                                                   $"private readonly int {IndexFieldName};{IndentedStringBuilder.NewLine}");
        var typeProperties = new IndentedStringBuilder(2);
        for (var i = 0; i < union.TypeParameters.Count; i++)
        {
            var type = union.TypeParameters[i];
            
            typeFields.AppendLine($"private readonly {type} {ValueFieldNamePrefix}{i};");
            typeProperties.AppendLine($"public bool Is{EnsureTitleCase(type)} => {IndexFieldName} == {i};");
        }

        return (typeFields.ToString(), typeProperties.ToString());
    }
    
    private static string EnsureTitleCase(string type)
    {
        Span<char> t = type.ToCharArray();
        t[0] = char.ToUpper(t[0]);
        return t.ToString();
    }
}
